# Defines the user and group Nginx will run as. 'www-data' is common for Debian/Ubuntu.
user www-data;
# The number of worker processes. 'auto' is a good default to leverage available CPU cores.
worker_processes auto;
# File to store the process ID of the main Nginx process.
pid /run/nginx.pid;

# -- EVENTS BLOCK --
# This section is mandatory and configures connection processing.
events {
    # The maximum number of simultaneous connections that can be opened by a worker process.
    worker_connections 768;
}

# -- HTTP BLOCK --
# This block contains the configuration for handling HTTP traffic.
http {
    # Define a map to correctly handle WebSocket connection upgrades.
    # This is more robust than a static "upgrade" value.
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # -- UPSTREAM SERVERS --
    # Defines pools of servers that Nginx can proxy requests to.

    upstream code_server {
        # For the VS Code server instance
        server 127.0.0.1:8080;
    }

    upstream dev_server {
        # For the primary development server
        server 127.0.0.1:3000;
    }

    upstream mcp_server {
        # For the control plane and authentication server
        # Note: Using 127.0.0.1 instead of 0.0.0.0 is standard practice for loopback.
        server 127.0.0.1:8000;
    }

    # -- VIRTUAL SERVER --
    # This block defines the configuration for a specific domain or IP address.

    server {
        listen 80;
        server_name your_domain.com; # Replace with your actual domain

        # -- AUTHENTICATION SUBREQUEST --
        # This is an internal-only location used by the `auth_request` directive.
        # It is not accessible from the outside world.
        location = /auth-validate-internal {
            internal;

            # Extract the 'auth' token from the original request's query string.
            # The $request_uri variable contains the full original URI, including arguments.
            set $auth_token "";
            if ($request_uri ~* [\?&]auth=([^&]+)) {
                set $auth_token $1;
            }

            # Proxy the subrequest to the authentication endpoint.
            proxy_pass http://mcp_server/auth-validate;
            proxy_pass_request_body off; # No need to send the original request body.
            proxy_set_header Content-Length "";
            proxy_set_header X-Original-URI $request_uri;

            # Set the Authorization header for the auth service using the extracted token.
            proxy_set_header Authorization "Bearer $auth_token";
        }

        # -- PROTECTED LOCATION: /8080 (VS Code Server) --

        # Exact match for /8080 to redirect and add a trailing slash.
        # This simplifies the main location block by ensuring a consistent path structure.
        location = /8080 {
            # Use a 301 redirect to preserve the query string.
            return 301 /8080/$is_args$args;
        }

        # Matches /8080/ and all subpaths.
        location /8080/ {
            # 1. Perform authentication via the internal subrequest.
            # If the /auth-validate-internal location returns a 2xx status, access is granted.
            # Otherwise, Nginx returns the error code from the subrequest (e.g., 401 or 403).
            auth_request /auth-validate-internal;

            # 2. Strip the 'auth' query parameter before proxying to the code_server.
            # This is necessary so the upstream application doesn't see our internal token.
            # This series of 'if' statements is a standard, if verbose, way to
            # handle query parameter removal in Nginx without using Lua.
            set $new_args $args;
            if ($args ~ ^auth=[^&]*$) { set $new_args ""; }
            if ($args ~ ^auth=[^&]*&(.*)) { set $new_args $1; }
            if ($args ~ (.*)&auth=[^&]*$) { set $new_args $1; }
            if ($args ~ (.*)&auth=[^&]*&(.*)) { set $new_args "$1&$2"; }
            set $args $new_args;

            # 3. Proxy the request to the code_server, enabling WebSocket support.
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # The trailing slash on the proxy_pass URL is crucial.
            # It tells Nginx to map `/8080/path/` to `http://code_server/path/`.
            proxy_pass http://code_server/;
        }

        # -- PROTECTED LOCATION: /dashboard --
        location /dashboard {
            # 1. Perform authentication.
            auth_request /auth-validate-internal;

            # 2. Strip the 'auth' query parameter.
            set $new_args $args;
            if ($args ~ ^auth=[^&]*$) { set $new_args ""; }
            if ($args ~ ^auth=[^&]*&(.*)) { set $new_args $1; }
            if ($args ~ (.*)&auth=[^&]*$) { set $new_args $1; }
            if ($args ~ (.*)&auth=[^&]*&(.*)) { set $new_args "$1&$2"; }
            set $args $new_args;

            # 3. Proxy to the dashboard on the mcp_server.
            proxy_pass http://mcp_server/dashboard;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # -- SSE ENDPOINT --
        # Exact match for /sse to prevent matching /sse/
        location = /sse {
            proxy_pass http://mcp_server/mcp;
            proxy_set_header Host $host;
            # Headers for Server-Sent Events (SSE)
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
            proxy_buffering off;
            proxy_cache off;
        }

        # -- DEFAULT LOCATION --
        # Catches all other requests and forwards them to the dev_server.
        location / {
            proxy_pass http://dev_server;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
